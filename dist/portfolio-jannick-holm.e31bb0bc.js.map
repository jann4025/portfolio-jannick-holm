{"version":3,"sources":["node_modules/rellax/rellax.js","index.js"],"names":["document","addEventListener","start","readScroll","rellax","Rellax","console","log","querySelector","menuOpen","querySelectorAll","forEach","links","scrollTop","documentElement","body","scrollBottom","clientHeight","scrollPercent","getElementById","style","setProperty","passive","countStats","classList","toggle","scrollPosY","window","pageYOffset","linkChangeHome","portfolioLinkChange","aboutLinkChane","remove","add","$","each","$this","countTo","attr","countNum","text","animate","duration","easing","step","Math","floor","complete"],"mappings":"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,CAAC,IAAD,CAAb;AAAA,ADJF,QCKGG,OAAO,GAAGD,KAAK,CAACE,IAAN,CAAW,YAAX,CADX;AAGAJ,ADNF,ICMEA,CAAC,CAAC;AAAEK,ADLN,MCKMA,QAAQ,EAAEH,KAAK,CAACI,IAAN;AAAZ,ADJJ,KCIG,CAAD,CAA8BC,OAA9B,CACC;AACCF,ADLJ,MCKIA,QAAQ,EAAEF;AADX,ADHH,KCEE,EAIC;AACCK,ADNJ,MCMIA,QAAQ,EAAE,IADX;AAECC,ADNJ,MCMIA,MAAM,EAAE,QAFT;AAGCC,ADNJ,MCMIA,IAAI,EAAE,gBAAW;AAChBR,ADNL,QCMKA,KAAK,CAACI,IAAN,CAAWK,IAAI,CAACC,KAAL,CAAW,KAAKP,QAAhB,CAAX;AACA,ADNL,OCCG;AAMCQ,ADNJ,MCMIA,QAAQ,EAAE,oBAAW;AACpBX,ADNL,QCMKA,KAAK,CAACI,IAAN,CAAW,KAAKD,QAAhB,EADoB,CAEpB;AACA,ADPL;ACFG,ADGH,KCPE;AAgBA,ADRF,GCZC;AAqBA,ADRD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"portfolio-jannick-holm.e31bb0bc.js","sourceRoot":"..","sourcesContent":["\n// ------------------------------------------\n// Rellax.js\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n}(typeof window !== \"undefined\" ? window : global, function () {\n  var Rellax = function(el, options){\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0;\n    var screenY = 0;\n    var posX = 0;\n    var screenX = 0;\n    var blocks = [];\n    var pause = true;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      function(callback){ return setTimeout(callback, 1000 / 60); };\n\n    // store the id for later use\n    var loopId = null;\n\n    // Test via a getter in the options object to see if the passive property is accessed\n    var supportsPassive = false;\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function() {\n          supportsPassive = true;\n        }\n      });\n      window.addEventListener(\"testPassive\", null, opts);\n      window.removeEventListener(\"testPassive\", null, opts);\n    } catch (e) {}\n\n    // check what cancelAnimation method to use\n    var clearLoop = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout;\n\n    // check which transform property to use\n    var transformProp = window.transformProp || (function(){\n        var testEl = document.createElement('div');\n        if (testEl.style.transform === null) {\n          var vendors = ['Webkit', 'Moz', 'ms'];\n          for (var vendor in vendors) {\n            if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {\n              return vendors[vendor] + 'Transform';\n            }\n          }\n        }\n        return 'transform';\n      })();\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n      center: false,\n      wrapper: null,\n      relativeToWrapper: false,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      callback: function() {},\n    };\n\n    // User defined options (might have more in the future)\n    if (options){\n      Object.keys(options).forEach(function(key){\n        self.options[key] = options[key];\n      });\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // check if el is a className or a node\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : [el];\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n      console.warn(\"Rellax: The elements you're trying to select don't exist.\");\n      return;\n    }\n\n    // Has a wrapper and it exists\n    if (self.options.wrapper) {\n      if (!self.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(self.options.wrapper);\n\n        if (wrapper) {\n          self.options.wrapper = wrapper;\n        } else {\n          console.warn(\"Rellax: The wrapper you're trying to use doesn't exist.\");\n          return;\n        }\n      }\n    }\n\n\n    // Get and cache initial position of all elements\n    var cacheBlocks = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n    };\n\n\n    // Let's kick this script off\n    // Build array for cached element values\n    var init = function() {\n      for (var i = 0; i < blocks.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      blocks = [];\n\n      screenY = window.innerHeight;\n      screenX = window.innerWidth;\n      setPosition();\n\n      cacheBlocks();\n\n      animate();\n\n      // If paused, unpause and set listener for window resizing events\n      if (pause) {\n        window.addEventListener('resize', init);\n        pause = false;\n        // Start the loop\n        update();\n      }\n    };\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function(el) {\n      var dataPercentage = el.getAttribute( 'data-rellax-percentage' );\n      var dataSpeed = el.getAttribute( 'data-rellax-speed' );\n      var dataZindex = el.getAttribute( 'data-rellax-zindex' ) || 0;\n      var dataMin = el.getAttribute( 'data-rellax-min' );\n      var dataMax = el.getAttribute( 'data-rellax-max' );\n\n      // initializing at scrollY = 0 (top of browser), scrollX = 0 (left of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY and posX needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var wrapperPosY = self.options.wrapper ? self.options.wrapper.scrollTop : (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n      // If the option relativeToWrapper is true, use the wrappers offset to top, subtracted from the current page scroll.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop);\n        wrapperPosY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n      var posY = self.options.vertical ? ( dataPercentage || self.options.center ? wrapperPosY : 0 ) : 0;\n      var posX = self.options.horizontal ? ( dataPercentage || self.options.center ? self.options.wrapper ? self.options.wrapper.scrollLeft : (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft) : 0 ) : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth;\n\n      // apparently parallax equation everyone uses\n      var percentageY = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      var percentageX = dataPercentage ? dataPercentage : (posX - blockLeft + screenX) / (blockWidth + screenX);\n      if(self.options.center){ percentageX = 0.5; percentageY = 0.5; }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = dataSpeed ? dataSpeed : self.options.speed;\n\n      var bases = updatePosition(percentageX, percentageY, speed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      var searchResult = /transform\\s*:/i.exec(style);\n      if (searchResult) {\n        // Get the index of the transform\n        var index = searchResult.index;\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g,'');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g,'');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax\n      };\n    };\n\n    // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function() {\n      var oldY = posY;\n      var oldX = posX;\n\n      posY = self.options.wrapper ? self.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n      posX = self.options.wrapper ? self.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n      // If option relativeToWrapper is true, use relative wrapper value instead.\n      if (self.options.relativeToWrapper) {\n        var scrollPosY = (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset;\n        posY = scrollPosY - self.options.wrapper.offsetTop;\n      }\n\n\n      if (oldY != posY && self.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX != posX && self.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n    var updatePosition = function(percentageX, percentageY, speed) {\n      var result = {};\n      var valueX = (speed * (100 * (1 - percentageX)));\n      var valueY = (speed * (100 * (1 - percentageY)));\n\n      result.x = self.options.round ? Math.round(valueX) : Math.round(valueX * 100) / 100;\n      result.y = self.options.round ? Math.round(valueY) : Math.round(valueY * 100) / 100;\n\n      return result;\n    };\n\n    // Remove event listeners and loop again\n    var deferredUpdate = function() {\n      window.removeEventListener('resize', deferredUpdate);\n      window.removeEventListener('orientationchange', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : window).removeEventListener('scroll', deferredUpdate);\n      (self.options.wrapper ? self.options.wrapper : document).removeEventListener('touchmove', deferredUpdate);\n\n      // loop again\n      loopId = loop(update);\n    };\n\n    // Loop\n    var update = function() {\n      if (setPosition() && pause === false) {\n        animate();\n\n        // loop again\n        loopId = loop(update);\n      } else {\n        loopId = null;\n\n        // Don't animate until we get a position updating event\n        window.addEventListener('resize', deferredUpdate);\n        window.addEventListener('orientationchange', deferredUpdate);\n        (self.options.wrapper ? self.options.wrapper : window).addEventListener('scroll', deferredUpdate, supportsPassive ? { passive: true } : false);\n        (self.options.wrapper ? self.options.wrapper : document).addEventListener('touchmove', deferredUpdate, supportsPassive ? { passive: true } : false);\n      }\n    };\n\n    // Transform3d on parallax element\n    var animate = function() {\n      var positions;\n      for (var i = 0; i < self.elems.length; i++){\n        var percentageY = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));\n        var percentageX = ((posX - blocks[i].left + screenX) / (blocks[i].width + screenX));\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        positions = updatePosition(percentageX, percentageY, blocks[i].speed);// - blocks[i].baseX;\n        var positionY = positions.y - blocks[i].baseY;\n        var positionX = positions.x - blocks[i].baseX;\n\n        // The next two \"if\" blocks go like this:\n        // Check if a limit is defined (first \"min\", then \"max\");\n        // Check if we need to change the Y or the X\n        // (Currently working only if just one of the axes is enabled)\n        // Then, check if the new position is inside the allowed limit\n        // If so, use new position. If not, set position to limit.\n\n        // Check if a min limit is defined\n        if (blocks[i].min !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY <= blocks[i].min ? blocks[i].min : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX <= blocks[i].min ? blocks[i].min : positionX;\n          }\n        }\n\n        // Check if a max limit is defined\n        if (blocks[i].max !== null) {\n          if (self.options.vertical && !self.options.horizontal) {\n            positionY = positionY >= blocks[i].max ? blocks[i].max : positionY;\n          }\n          if (self.options.horizontal && !self.options.vertical) {\n            positionX = positionX >= blocks[i].max ? blocks[i].max : positionX;\n          }\n        }\n\n        var zindex = blocks[i].zindex;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(' + (self.options.horizontal ? positionX : '0') + 'px,' + (self.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(positions);\n    };\n\n    self.destroy = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n\n      // Remove resize event listener if not pause, and pause\n      if (!pause) {\n        window.removeEventListener('resize', init);\n        pause = true;\n      }\n\n      // Clear the animation loop to prevent possible memory leak\n      clearLoop(loopId);\n      loopId = null;\n    };\n\n    // Init\n    init();\n\n    // Allow to recalculate the initial values whenever we want\n    self.refresh = init;\n\n    return self;\n  };\n  return Rellax;\n}));\n","import Rellax from 'rellax';\n('use strict');\ndocument.addEventListener('DOMContentLoaded', start);\n\ndocument.addEventListener('scroll', readScroll);\n\nfunction start() {\n\tvar rellax = new Rellax('.rellax');\n\tconsole.log('Connection between the DOM and the Script was successfull! Nice ðŸ˜Ž');\n\tdocument.querySelector('.button_container').addEventListener('click', menuOpen);\n\tdocument.querySelectorAll('ul li a span').forEach((links) => {\n\t\tlinks.addEventListener('click', menuOpen);\n\t});\n\n\tdocument.addEventListener(\n\t\t'scroll',\n\t\tfunction() {\n\t\t\tlet scrollTop = document.documentElement['scrollTop'] || document.body['scrollTop'];\n\t\t\tlet scrollBottom =\n\t\t\t\t(document.documentElement['scrollHeight'] || document.body['scrollHeight']) -\n\t\t\t\tdocument.documentElement.clientHeight;\n\t\t\tlet scrollPercent = scrollTop / scrollBottom * 100 + '%';\n\t\t\tdocument.getElementById('_progress').style.setProperty('--scroll', scrollPercent);\n\t\t},\n\t\t{ passive: true }\n\t);\n\n\tcountStats();\n}\n\nfunction menuOpen() {\n\tdocument.querySelector('.button_container').classList.toggle('menu-open');\n\tdocument.querySelector('.menu').classList.toggle('open');\n}\n\nfunction readScroll() {\n\tlet scrollPosY = window.pageYOffset;\n\tconsole.log(scrollPosY);\n\n\tscrollPosY >= 0 || scrollPosY < 701 ? linkChangeHome() : '';\n\tscrollPosY >= 701 ? portfolioLinkChange() : '';\n\tscrollPosY >= 3296 ? aboutLinkChane() : '';\n\t\n}\n\nfunction linkChangeHome() {\n\tdocument.querySelector('.active').classList.remove('active');\n\tdocument.querySelector('.home-link').classList.add('active');\n}\n\nfunction portfolioLinkChange() {\n\tdocument.querySelector('.active').classList.remove('active');\n\tdocument.querySelector('.portfolio-link').classList.add('active');\n}\n\nfunction aboutLinkChane() {\n\tdocument.querySelector('.active').classList.remove('active');\n\tdocument.querySelector('.about-link').classList.add('active');\n}\n\nfunction countStats() {\n\t// number count for stats, using jQuery animate\n\t$('.counting').each(function() {\n\t\tvar $this = $(this),\n\t\t\tcountTo = $this.attr('data-count');\n\n\t\t$({ countNum: $this.text() }).animate(\n\t\t\t{\n\t\t\t\tcountNum: countTo\n\t\t\t},\n\t\t\t{\n\t\t\t\tduration: 2000,\n\t\t\t\teasing: 'linear',\n\t\t\t\tstep: function() {\n\t\t\t\t\t$this.text(Math.floor(this.countNum));\n\t\t\t\t},\n\t\t\t\tcomplete: function() {\n\t\t\t\t\t$this.text(this.countNum);\n\t\t\t\t\t//alert('finished');\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t});\n}\n"]}